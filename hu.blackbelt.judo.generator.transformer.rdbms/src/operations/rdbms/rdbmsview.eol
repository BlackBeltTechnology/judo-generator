import "../psm/_importPsm.eol";

// Base alias is a reference for base table
operation RDBMS!RdbmsView createBaseAlias(class : PSM!JClass) : RDBMS!RdbmsTableAlias {
    var baseAlias : RDBMS!RdbmsTableAlias = new RDBMS!RdbmsTableAlias();
    baseAlias.table = class.equivalent("JClassToRdbmsTable");
    baseAlias.name = baseAlias.table.name;
    baseAlias.description = "Base " + baseAlias.table.name;
    baseAlias.sqlName = "BASE_" + baseAlias.table.sqlName;
	baseAlias.uuid = generateUuid(self.uuid, "TableAlias", "_");

    self.tables.add(baseAlias);
    self.primaryTable = baseAlias;
    return baseAlias;
}

operation RDBMS!RdbmsView addPrimaryKeyField(attribute : PSM!JAttribute) {
    var f : RDBMS!RdbmsViewField;
	f = attribute.equivalent("JAttributeToViewIdField");
	f.`alias` = self.primaryTable;
	// f.name.println("Addig primary key field: ");
  	self.fields.add(f);	
  	self.primaryIdentifierField = f;
}

operation RDBMS!RdbmsView addValueField(attribute : PSM!JAttribute) : RDBMS!RdbmsViewField {
    var f : RDBMS!RdbmsViewField;
	f = attribute.equivalent("JAttributeToViewValueField");
	f.`alias` = self.primaryTable;
	// f.name.println("Addig value field: ");
  	self.fields.add(f);
  	return f;
}

operation RDBMS!RdbmsView createRoleReferenceField(role : PSM!JRole) : RDBMS!RdbmsViewIdentifierField {
	var vi : RDBMS!RdbmsViewIdentifierField = new RDBMS!RdbmsViewIdentifierField();
	vi.name = role.roleAliasName(); 
	vi.sqlName = role.roleIdSqlName();
	vi.description =  role.opposite().name + " (" + role.opposite().ownerClass.name + ")";
	vi.uuid = generateUuid(role.uuid, "ViewField", "_");
	return vi;
}

// Create reference field when the ID is owned in the base table
operation RDBMS!RdbmsView addOwnedRelationField(role : PSM!JRole) {
	var vi : RDBMS!RdbmsViewIdentifierField = self.createRoleReferenceField(role);
	vi.description += " Owned Relation";
	vi.tableField = role.equivalent("JRoleToRdbmsTableForeignKey");
	vi.`alias` = self.primaryTable;
	self.fields.add(vi);
}


// Create reference field when the ID field is on the foreign table
operation RDBMS!RdbmsView addForeignRelationField(role : PSM!JRole) {
	var vi : RDBMS!RdbmsViewForeignIdentifierField = new RDBMS!RdbmsViewForeignIdentifierField();
	vi.name = role.roleAliasName(); 
	vi.sqlName = 'INV_' + role.roleIdSqlName();
	vi.description =  role.opposite().name + " (" + role.opposite().ownerClass.name + ")";
	vi.uuid = generateUuid(role.uuid, self.name, ".");
	vi.description += " Foreign Relation";
	vi.tableField = role.opposite().equivalent("JRoleToRdbmsTableForeignKey");
	vi.referenceIdentifier = self.primaryIdentifierField;
	self.fields.add(vi);
}

operation RDBMS!RdbmsView addExpressionField(attribute : PSM!JAttribute) {
    var vf : RDBMS!RdbmsViewField;
	
	vf = attribute.equivalent("JAttributeToViewExpressionField");

	self.fields.add(vf);
	
	vf.uuid = generateUuid(attribute.uuid, self.name, ".");
   	vf.view = self;  		 
   		    		 
   	// (attribute.ownerClass.name + "." + attribute.name).println("EXPRESSION FOUND: ");
   		
   	for (expr in parseDerivedExpression(attribute.value)) {
    	if (expr.isExpressionLabelExpression()) {
    		var labelExpression : RDBMS!RdbmsLabelExpression = new RDBMS!RdbmsLabelExpression();
    		labelExpression.expression = expr.getLabelExpression().getText();
    		labelExpression.text = expr.getLabelExpression().getText();
    		labelExpression.uuid = generateUuid(attribute.uuid, expr.getLabelExpression().getText(), ".");
    		labelExpression.sqlName = labelExpression.uuid;
    		vf.expressions.add(labelExpression);
    	} else if (expr.isExpressionRelationExpression()) {

			var currentRelationExpression = new RDBMS!RdbmsRelationExpression();
			vf.expressions.add(currentRelationExpression);

			var currentParsedRelationExpression = expr.getRelationExpression();
			
			// The root always is the base class
			var currentClass : PSM!JClass = attribute.ownerClass;
			var currentRelationName : String = currentClass.equivalent("JClassToRdbmsTable").name;  //"";

			// Prefix the field names with the expression field name
			var currentRelationIdentifierFieldName : String = attribute.name;
			
			// The root identifier is always the view's primary field.
			var currentRelationIdentifierField : RDBMS!RdbmsViewIdentifierField = self.primaryIdentifierField; // currentClass.id().equivalent("JAttributeToViewIdField");
		    var currentAlias : RDBMS!RdbmsTableAlias = self.primaryTable;
		    var currentAliasName : String = "";
		    var previousAliasName : String = "";
						
			// Parsing the chain of the expressions
			while (currentParsedRelationExpression.isDefined()) {
				// Search for role. If there is another part, it have to be a relation.
				if (currentParsedRelationExpression.hasChild()) {
					if (currentAliasName <> "") {
						currentAliasName += ".";
					} 
					currentRelationName += "." + currentParsedRelationExpression.getRelationName(); 
					currentAliasName += currentParsedRelationExpression.getRelationName();

					var currentRole : PSM!JRole = currentClass.allRoles().select(sr | sr.name == currentParsedRelationExpression.getRelationName()).first;
					if (currentRole.isUndefined()) {
						throw "Role " + currentParsedRelationExpression.getRelationName() +" not found on class: " + currentClass.name; 
					}

					// Find or create alias for the relation
					var previousAlias = currentAlias;
					currentAlias = self.findOrAddAlias(currentRole, currentAliasName);					
					
					// Add relation identifier field. TODO: Now ignored
				    // currentRelationIdentifierField = self.findOrAddViewRelationIdentifierField(currentRole, currentRelationName, previousAlias, currentAlias);

					// Add relation.
					if (currentRole.isForeign()) {
						self.findOrAddRelation(previousAlias, currentAlias, currentRole.equivalent("JRoleToRdbmsTableForeignKey"), currentAlias.table.primaryKey);
					} else {
						self.findOrAddRelation(previousAlias, currentAlias, previousAlias.table.primaryKey, currentRole.opposite().equivalent("JRoleToRdbmsTableForeignKey"));
					}


					// For the next round the base class will be the relation's class on the orher side
					currentClass = currentRole.opposite().ownerClass;
					
					currentParsedRelationExpression = currentParsedRelationExpression.getRelationExpression();						
				} else {
					// (currentClass.name + " " + currentParsedRelationExpression.getRelationName()).println("Current class: ");
					var relAttr : PSM!JAttribute = currentClass.allAttributes().select(sa | sa.name == currentParsedRelationExpression.getRelationName()).first;
					currentRelationExpression.expression = currentParsedRelationExpression.getRelationName();

					if (relAttr.isUndefined()) {
						var role : PSM!JRole = currentClass.allRoles().select(sr | sr.name == currentParsedRelationExpression.getRelationName()).first;
						if (role.isUndefined()) {
							throw "No attribute or role is undefined on relation: " + currentClass.name + " " + currentParsedRelationExpression.getRelationName();
						} else {
							// role.name.println("Role: ");
							
							// TODO: Check if role have a representation. If yes, have to use that one.
							// Recursively have to traverse. 
							// Now fast solution we put ID on normal role as representation, for Enum using Code.
							if (role.opposite().ownerClass.representsEnum) {									
								"- ENUM Value".println();
							}
							relAttr = role.opposite().ownerClass.allAttributes().select(sa | sa.name == "code").first;
						}																								
					}
					
					if (relAttr.isDefined()) {
						// Check the type is identifier field or not. Have to find better way to determinate.
						if (relAttr.name == "id") {
							currentRelationExpression.field = currentRelationIdentifierField;
						} else {					

							var valueFieldName = currentAlias.name + "." + relAttr.name;							
							
							// The attribute exists in the base table or inherited attribute of the base table
							if (attribute.ownerClass == relAttr.ownerClass or attribute.ownerClass.allSupertypes().contains(relAttr.ownerClass)) {
								currentRelationExpression.field =  relAttr.equivalent("JAttributeToViewValueField");	
							// Foreign referenced field
							} else {
								var foreignValueField : RDBMS!RdbmsViewField = self.fields.select(s | s.name == valueFieldName).first;
							
							    if (foreignValueField.isUndefined()) {
									foreignValueField = new RDBMS!RdbmsViewValueField(); 
									self.fields.add(foreignValueField);
									foreignValueField.foreign = true;
									foreignValueField.view = self;
									foreignValueField.name = valueFieldName;								
									foreignValueField.sqlName = currentAlias.sqlName + "_" + relAttr.ownerClass.classSqlName() + "_" + relAttr.sqlName();
									foreignValueField.uuid = generateUuid(relAttr.ownerClass.uuid, currentParsedRelationExpression.getRelationName() + "_" + currentAlias.name, ".");
									foreignValueField.description = currentRelationName + "." + relAttr.name;
									foreignValueField.tableField = relAttr.equivalent("JAttributeToTableValueField");
							
									// The relation attribute is an inherited attribute 	
									if (relAttr.ownerClass <> currentClass) {
										// (currentClass.fqName() + relAttr.ownerClass.fqName()).println("The used attribute is an inherited attribute: ");
										
										// Adding alias for superclass if does not exists.
										var relationSuperAlias = self.findOrAddAliasByClassPair(currentClass, relAttr.ownerClass, 
											currentRelationName + " Descendant Of " + relAttr.ownerClass.fqName(), 
											currentAliasName + "@" + relAttr.ownerClass.fqName());					

										// Add relation identifier field. TODO: Now ignored
					    				// currentRelationIdentifierField = self.findOrAddViewRelationIdentifierField(currentRole, currentRelationName, previousAlias, currentAlias);

										// Add relation.
										self.findOrAddRelation(currentAlias, relationSuperAlias, currentAlias.table.primaryKey, relationSuperAlias.table.primaryKey);

										foreignValueField.`alias` = relationSuperAlias;
																														
									// The attribute owned the foreign class itself
									} else {
										// relAttr.name.println("Foreign field added: ");
										foreignValueField.`alias` = currentAlias;
							    	}
						    	}
						    	currentRelationExpression.field = foreignValueField;
							}

							currentRelationExpression.sqlName = currentRelationExpression.field.sqlName;
							currentRelationExpression.name = currentRelationExpression.field.name;																	
							currentRelationExpression.shortName = currentRelationExpression.field.shortName;																	
							currentRelationExpression.fullName = currentRelationExpression.field.fullName;																	
							currentRelationExpression.uuid = generateUuid(currentRelationExpression.field.uuid, currentRelationName + " @ " + relAttr.ownerClass.fqName(), ".");
							currentRelationExpression.description = currentRelationName + "." + relAttr.name;

						}
						// Check if field added or not
						if (not self.fields.select(s | s.name == currentRelationIdentifierFieldName).isEmpty()) {
							self.fields.add(currentRelationExpression.field);
						}
					}
					currentParsedRelationExpression = null;
				}
			}
		}
	}

  	// vf.name.println("Addig expression field: ");
}

operation RDBMS!RdbmsView findOrAddAliasByClassPair(class : PSM!JClass, oppositeClass : PSM!JClass, aliasName : String, relationName : String) : RDBMS!RdbmsTableAlias {
	var currentAlias : RDBMS!RdbmsTableAlias = self.tables.select(e | e.name = aliasName).first;

	// Creaate alias
	if (currentAlias.isUndefined()) {
		currentAlias = new RDBMS!RdbmsTableAlias();
		self.tables.add(currentAlias);
		currentAlias.table = oppositeClass.equivalent("JClassToRdbmsTable");
		currentAlias.uuid = generateUuid(self.uuid, relationName + "TableAlias", ".");
		currentAlias.sqlName = 'REL_' + abbreviate(relationName.replaceAll("\\.", "").replaceAll("@", ""), 26).toUpperCase();
		currentAlias.name = aliasName;
	}
	return currentAlias;
}


operation RDBMS!RdbmsView findOrAddAlias(role : PSM!JRole, relationName : String) : RDBMS!RdbmsTableAlias {
	// Find alias
	var aliasName : String = role.ownerClass.package.fqName() +  "." + role.ownerClass.name;
	if (relationName.isDefined() and relationName <> "") {
		aliasName += "." + relationName;
	}
    return self.findOrAddAliasByClassPair(role.ownerClass, role.opposite().ownerClass, aliasName, relationName);
}

operation RDBMS!RdbmsView findOrAddRelation(fromAlias : RDBMS!RdbmsTableAlias, toAlias : RDBMS!RdbmsTableAlias, fromField : RDBMS!RdbmsIdentifierField, toField : RDBMS!RdbmsIdentifierField) : RDBMS!RdbmsViewRelation {
	// Find relation
	var relationName =  fromAlias.name + " to " + toAlias.name;
	
	var currentRelation : RDBMS!RdbmsViewRelation = self.relations.select(s | s.name = relationName).first;

	// Creaate relation
	if (currentRelation.isUndefined()) {
		currentRelation = new RDBMS!RdbmsViewRelation();
		self.relations.add(currentRelation);
		currentRelation.name = relationName;
		currentRelation.fromAlias = fromAlias;
		currentRelation.toAlias = toAlias;
		currentRelation.fromField = fromField;
		currentRelation.toField = toField;
	} 
	return currentRelation;
}

/* 
	Clone view fields
	Two phases: 
		- first all fields which is not expression based
		- second the expression which can reference to other fields
*/
operation RDBMS!RdbmsView addSupertypeViewFields(baseView : RDBMS!RdbmsView) : RDBMS!RdbmsView {
	for (a : RDBMS!RdbmsViewField in baseView.fields.select(f | not f.isKindOf(RDBMS!RdbmsViewExpressionField))) {
		self.addSupertypeViewField(a);
	}
	for (a : RDBMS!RdbmsViewField in baseView.fields.select(f | f.isKindOf(RDBMS!RdbmsViewExpressionField))) {
		self.addSupertypeViewField(a);
	}
	return self;
}

operation RDBMS!RdbmsView addSupertypeViewField(original : RDBMS!RdbmsViewField) : RDBMS!RdbmsViewField  {

	var created : RDBMS!RdbmsViewField = original.clone();
	self.fields.add(created);
	created.uuid = generateUuid(original.uuid, self.name, ".");
	created.inherited = true;
	created.view = self;

	// Set alias instance link to cloned alias
	if (created.isKindOf(RDBMS!RdbmsViewAliasField)) {
	    if (created.tableField = created.tableField.table.primaryKey and created.isTypeOf(RDBMS!RdbmsViewIdentifierField)) {
	    	created.sqlName = "C_" + created.`alias`.table.sqlName + "_ID";
	    }	    		    
		created.`alias` = self.tables.select(e | e.name == created.`alias`.name).first();
	} else if (created.isKindOf(RDBMS!RdbmsViewForeignIdentifierField)) {
		created.referenceIdentifier = self.fields.select(f | f.name == original.referenceIdentifier.name).first();
	} else if (created.isKindOf(RDBMS!RdbmsViewExpressionField)) {
		for (exp : RDBMS!RdbmsExpression in created.expressions) {
			if (exp.isKindOf(RDBMS!RdbmsRelationExpression)) {
				exp.field = self.fields.select(f | f.name == exp.field.name).first();
			}
		}
	}
	
	return created;
}

operation RDBMS!RdbmsView addSupertypeRelations(baseView : RDBMS!RdbmsView) : RDBMS!RdbmsView {
	// Clone relations
	for (r : RDBMS!RdbmsViewRelation in baseView.relations) {
		var created : RDBMS!RdbmsViewRelation = r.clone();
		self.relations.add(created);
		created.fromAlias = self.tables.select(f | f.name == r.fromAlias.name).first(); 
		created.toAlias = self.tables.select(f | f.name == r.toAlias.name).first(); 
	}
	return self;
}

operation RDBMS!RdbmsView addSupertypeAliases(baseView : RDBMS!RdbmsView) : RDBMS!RdbmsTableAlias {
	var superAlias : RDBMS!RdbmsTableAlias;
	for (f : RDBMS!RdbmsTableAlias in baseView.tables.clone()) {

		var created : RDBMS!RdbmsTableAlias = f.clone();
		self.tables.add(created);
		created.uuid = generateUuid(f.uuid, self.name, ".");
		created.description = "Super " + f.table.name;
		created.sqlName = "SUP_" + f.table.sqlName;

		if (baseView.primaryTable == f) {
			superAlias = created;
		}
		// created.println("Created: ");
	}
	return superAlias;
}

