import "operations/_importAll.eol";

pre {
	"START".println();
	
	//i need to extract the derived information from the UML as this info is lost during PIM/PSM transformation 	
	var ecxludedFields : Set<String> = inpPIM!Property.all.select(p | p.isDerived 
																or p.visibility = inpPIM!VisibilityKind#private
																/*or p.visibility = inpPIM!VisibilityKind#protected*/)
													.collect(p | p.fqName()).asSet();
													
	//all things from extension model must be excluded
	ecxludedFields.addAll(pimEXT!EStructuralFeature.all.collect(a | a.fqName()));
	//additional field exclusions
	ecxludedFields.add("anakin.business.domain.ugylet.termek.KolcsonSema.modositasDatuma");
	ecxludedFields.add("anakin.business.domain.ugylet.termek.KolcsonSema.modositoFelhasznalo");
	ecxludedFields.add("anakin.business.domain.felhasznalo.Felhasznalo.becsusiKolcsonLimit");
	ecxludedFields.add("anakin.business.domain.felhasznalo.Felhasznalo.lastFailedLoginTime");
	ecxludedFields.add("judo.framework.User.credential");
	ecxludedFields.add("judo.framework.User.lastLoginTime");
	ecxludedFields.add("judo.framework.User.sms");
	ecxludedFields.add("judo.framework.User.notificationEmail");
	ecxludedFields.add("judo.framework.User.notificationSms");
	
	//we can defined classes to be excluded
	var excludedClasses : Set<String> = new Set;
	excludedClasses.add("judo.framework.UserInfo");
	
	var additionalRoles : Set<String> = new Set;
	//there are roles that are not mandatory in uml, but must be included due to business requirement
	additionalRoles.add("Anakin.anakin.business.domain.ugylet.elzalogositas.Ajanlat.zalogtetelek");
	additionalRoles.add("Anakin.anakin.business.domain.ugylet.Szerzodes.zalogtargyBecslesek");
	additionalRoles.add("Anakin.anakin.business.domain.targy.ZalogtargyBecsles.zalogtargy");
	additionalRoles.add("Anakin.anakin.business.domain.targy.Zalogtargy.feljegyzesek");
	additionalRoles.add("Anakin.anakin.business.domain.targy.Zalogtargy.raktariTetel");
	additionalRoles.add("Anakin.anakin.business.domain.raktar.RaktariTetel.feljegyzesek");
	additionalRoles.add("Anakin.anakin.business.domain.raktar.RaktariTetel.tarolohely");
	additionalRoles.add("Anakin.anakin.business.domain.raktar.Tarolohely.raktar");
	
	//later use for flagging elotoltott data as we need to remame them in the migration schema
	var elotoltott : Set<String> = new Set;
	elotoltott.add("anakin.business.domain.ugylet.termek.AdhatoKolcsonSzorzo");
	elotoltott.add("anakin.business.domain.ugylet.termek.Termek");
	elotoltott.add("anakin.business.domain.targy.Arfolyam");
	elotoltott.add("anakin.business.domain.ugylet.termek.Dijszabas");
	elotoltott.add("anakin.business.domain.targy.Finomsag");
	elotoltott.add("anakin.business.domain.ugylet.termek.KolcsonSema");
	elotoltott.add("anakin.business.domain.szervezet.KozvetitoCeg");
	elotoltott.add("anakin.business.domain.felhasznalo.Privilegium");
	elotoltott.add("anakin.business.domain.felhasznalo.Szerepkor");
	elotoltott.add("anakin.business.domain.targy.TargyleirasRoviditesek");
	elotoltott.add("anakin.business.domain.ugylet.termek.TermekKategoria");
	elotoltott.add("anakin.business.domain.ugylet.termek.Termek");
	elotoltott.add("anakin.business.domain.ugylet.termek.Termekverzio");
	elotoltott.add("anakin.business.domain.ugylet.UzletiKonfiguracio");
	elotoltott.add("anakin.business.domain.targy.Zalognem");
	
	//later use for flagging enum classes as we need to remame them in the migration schema
	var enumClasses = PSM!JClass.all.select(c | c.representsEnum).collect(c | c.fqName()).asSet();
	var enumTableNamesMap : Map<String, String> = new Map;
	var elotoltottTableNamesMap : Map<String, String> = new Map;
	
	//the class from where we want to start the transitive colsure on mandatory and above defiend additional roles	
	var startClassName = "anakin.business.domain.ugylet.elzalogositas.ElzalogositasSzerzodes";
	var startClass = PSM!JClass.all.selectOne(c | c.fqName() = startClassName);
	var classUUIDs : Set<String> = new Set;
	classUUIDs.add(startClass.uuid);
	startClass.allMandatoryRoles(classUUIDs);
	classUUIDs = classUUIDs.collect(a | a + "_View").asSet();
	var viewNames : Set<String> = RDBMS!RdbmsView.all.select(v | classUUIDs.contains(v.uuid)).name.asSet();
	//remove excluded classes
	viewNames.removeAll(excludedClasses);
	
}

operation PSM!JClass allMandatoryRoles(acc : Set<String>) {
	for (r in PSM!JRole.all.select(r | r.ownerClass = self or r.ownerClass = self.supertype)) { //supertype collctor must be recursive 
		if (r.lower > 0 or additionalRoles.contains(r.uuid)) {
			var opp = r.opposite().ownerClass;
			if (not opp.`abstract` and not acc.contains(opp.uuid)) {
				acc.add(opp.uuid);
				r.opposite().ownerClass.allMandatoryRoles(acc);
			}
		}
	}
}

@abstract
rule Element 
	transform s : RDBMS!RdbmsElement
	to 		  t : MIG!RdbmsElement {
	guard: not s.name.contains("@") //TODO: find out why multichained derived expressions maps to valueField
		t.name = s.name;
		t.uuid = s.uuid;
		t.fullName = s.fullName;
		t.description = s.description;
		t.shortName = s.sqlName; // I am using the shortName for storing the original sqlName for later use
		t.sqlName = s.name.cutFqNameToLastElement();
		t.originalName = s.originalName;
	    t.originalPackage = s.originalPackage;
}

@abstract
rule ViewField 
	transform s : RDBMS!RdbmsViewTableField
	to 		  t : MIG!RdbmsField
	extends Element {
		t.rdbmsTypeName = s.tableField.rdbmsTypeName;
		t.size = s.tableField.size;
		t.precision = s.tableField.precision;
		t.scale = s.tableField.scale;
		t.storageByte = s.tableField.storageByte;
		t.mandatory = s.tableField.mandatory;
}

rule Model 
	transform s : RDBMS!RdbmsModel
	to 		  t : MIG!RdbmsModel {
		t.version = s.version;
		for (v in s.rdbmsViews) {
			if (viewNames.contains(v.name)) {
				t.rdbmsTables.add(v.equivalent());
			} 
		}
	}

@lazy
rule View 
	transform s : RDBMS!RdbmsView
	to 		  t : MIG!RdbmsTable
	extends Element {
		var pk = s.primaryIdentifierField;
	    t.primaryKey = pk.equivalent();
	    t.fields.add(t.primaryKey);
	    for (f in s.fields) {
	    	if (not f.isTypeOf(RDBMS!RdbmsViewExpressionField) 
	    		and not f.equals(pk) 
	    		and not f.uuid.isExcludedField(s.name)
	    		and not t.fields.exists(x | x.name.cutFqNameToLastElement() = f.name.cutFqNameToLastElement())) {
	    		var fe = f.equivalent();
	    		if (fe.isDefined()) {
	    			t.fields.add(fe);
	    		}
	    	}
		}
		if (elotoltott.contains(t.name)) {
			//prefix elotoltott tables
			t.sqlName = "ET_" + t.sqlName;
			//helper map for making easier the dump manipulation see the grep sed command at the end 
			elotoltottTableNamesMap.put(t.originalTableName(), t.sqlName);
			
		} else if (enumClasses.contains(t.name)) {
			//prefix enum tables
			t.sqlName = "ENUM_" + t.sqlName;
			//helper map for making easier the dump manipulation see the grep sed command at the end
			enumTableNamesMap.put(t.originalTableName(), t.sqlName);
		}
	}

@lazy
rule ViewIdField
	transform s : RDBMS!RdbmsViewIdentifierField
	to t : MIG!RdbmsIdentifierField 
	extends ViewField {
	guard : not RDBMS!RdbmsForeignKey.all.exists(f | f.name = s.name)
}

@lazy
rule ViewValueField
	transform s : RDBMS!RdbmsViewValueField
	to t : MIG!RdbmsValueField 
	extends ViewField {
	guard: not s.tableField.technical 
		   and (not enumClasses.contains(s.tableField.table.name) or s.name.cutFqNameToLastElement() = "code") //hack i only need the code for enums 
}

@lazy
rule Fk
	transform s : RDBMS!RdbmsForeignKey
	to fk : MIG!RdbmsForeignKey 
	extends Element {
		fk.rdbmsTypeName = s.rdbmsTypeName;
		fk.size = s.size;
		fk.precision = s.precision;
		fk.scale = s.scale;
		fk.storageByte = s.storageByte;
		fk.mandatory = s.mandatory;
		
	    fk.referenceKey = MIG!RdbmsIdentifierField.all.selectOne(f | f.name = s.referenceKey.name);
	    
	    fk.foreignKeySqlName = s.foreignKeySqlName;
		fk.table =  MIG!RdbmsTable.all.selectOne(t | t.name = s.table.name);

		fk.mandatory = s.mandatory;
		
		fk.deleteOnCascade = s.deleteOnCascade;
		fk.readOnly = s.readOnly;
}

@lazy
rule Junction
	transform s : RDBMS!RdbmsJunctionTable
	to j : MIG!RdbmsJunctionTable 
	extends Element {
		for (i in s.fields.select(f | f.isTypeOf(RDBMS!RdbmsIdentifierField))) {
			var p : RDBMS!RdbmsIdentifierField = new RDBMS!RdbmsIdentifierField;
			p.name = i.name;
			p.sqlName = i.sqlName;
			p.rdbmsTypeName = i.rdbmsTypeName;
			p.uuid =  i.uuid;
			p.rdbmsTypeName = i.rdbmsTypeName;
			p.size = i.size;
			p.precision = i.precision;
			p.scale = i.scale;
			p.storageByte = i.storageByte;
			p.mandatory = i.mandatory;		
			j.fields.add(p);
		}
		
		var n = s.name.split(" to ").collect(s | s.cutFqNameToLastElement());
		j.sqlName = n.first() + "_" + n.second() ;

		j.field1 = s.field1.equivalent();
		j.field2 = s.field2.equivalent();
}

operation String cutFqNameToLastElement() : String {
	var start = self.lastindexOf(".");
	return self.substring(start + 1, self.length());
}

operation String isExcludedField(viewName : String) : Boolean {
	var e = ecxludedFields.collect(e | "Anakin." + e + "_ViewField@Anakin." + viewName + "_View");
	return e.contains(self) ;
}

operation MIG!RdbmsTable originalTableName() : String {
	return "t_"  + self.shortName.substring(2).toLowerCase();
}

operation printEnumMod() {
	var grepAndSedCommand = "grep -E \"%s\"";
	var tables = "";
	var sed = "";
	for (k in enumTableNamesMap.keySet()) {
		tables += "INSERT INTO ";
		tables += k.toLowerCase();
		tables += "|";
		
		sed += "s/" + k.toLowerCase() + "/" + enumTableNamesMap.get(k) + "/g;";
	}
	var first = tables.substring(0, tables.length()-1).format(grepAndSedCommand).println("GREP: ");
	var second = "awk '{print $1 \" \" $2 \" \" $3 \" \" $4 \" \" $5  \") VALUES(\" $14 \" \" $15 \");\"}' | sed 's/,) /) /g;s/.);/);/g'".println("AWK 1: ");
	sed += "s/c_code/code/g";
	var third = sed.format("sed '%s'").println("SED: ");
	var all = first + " | " + second + " | " + third;
	all.println("ALL: ");
	
}

operation printETMod() {
	var grepAndSedCommand = "grep -E \"%s\"";
	var tables = "";
	var sed = "";
	for (k in elotoltottTableNamesMap.keySet()) {
		tables += "INSERT INTO ";
		tables += k.toLowerCase();
		tables += "|";
		
		sed += "s/" + k.toLowerCase() + "/" + elotoltottTableNamesMap.get(k) + "/g;";
	}
	
	for (f in MIG!RdbmsField.all.select(x | elotoltottTableNamesMap.keySet().contains(x.table.originalTableName()))) {
		if (not f.equals(f.table.primaryKey)) {
			sed += "s/" + f.shortName.toLowerCase() + "/" + f.sqlName + "/g;";
		}
	}
	
	var first = tables.substring(0, tables.length()-1).format(grepAndSedCommand).println("GREP: ");
	var second = sed.substring(0, sed.length()-1).format("sed '%s'").println("SED: ");
	var all = first + " | " + second;
	all.println("ALL: ");
}

post {
	for (fk in RDBMS!RdbmsForeignKey.all) {
	    var refKey = MIG!RdbmsIdentifierField.all.selectOne(f | f.name = fk.referenceKey.name);
	    var fkName = "Anakin." + fk.name;
	    var isMandatory = PSM!JRole.all.selectOne(r | r.uuid = fkName and r.lower > 0).isDefined();
	    var table = MIG!RdbmsTable.all.selectOne(t | t.name = fk.table.name);
	    if (refKey.isDefined() 
	    	and table.isDefined() 
	    	and (isMandatory or additionalRoles.contains(fkName)) 
	    	and not ecxludedFields.contains(fk.name)) {
			fk.equivalent();
	    }
	}
	for (j in RDBMS!RdbmsJunctionTable.all) {
		var table1 = MIG!RdbmsTable.all.selectOne(t | t.name = j.field1.referenceKey.table.name);
		var table2 = MIG!RdbmsTable.all.selectOne(t | t.name = j.field2.referenceKey.table.name);
		var refKey1 = MIG!RdbmsIdentifierField.all.selectOne(f | f.name = j.field1.referenceKey.name);
		var refKey2 = MIG!RdbmsIdentifierField.all.selectOne(f | f.name = j.field1.referenceKey.name);
		if (table1.isDefined() and table2.isDefined() and refKey1.isDefined() and refKey2.isDefined()) {
			MIG!RdbmsModel.all.first().rdbmsTables.add(j.equivalent()); 
		}
	}
	
	//Helper command line things to extract a dump and then extract the preloaded and enum tables for insert, as the migratin schema must contain these records
	"You can use these command snippets to replace and shape the extracted dump file".println();
	printEnumMod();
	printETMod();
	"pg_dump -a -O --column-inserts -d anakin -U anakin -w -f anakin.sql".println("Use this command for dumnping preloaded and enum data from a running anakin system.");
	
	"END".println();
	
}