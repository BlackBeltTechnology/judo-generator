import "operations/_importAll.eol";

pre {
	"START".println();
	
	//i need to extract the derived information from the UML as this info is lost during PIM/PSM transformation 	
	var excludes : Set<String> = inpPIM!Property.all.select(p | p.isDerived 
																or p.visibility = inpPIM!VisibilityKind#private
																/*or p.visibility = inpPIM!VisibilityKind#protected*/)
													.collect(p | p.fqName()).asSet();
													
	//all things from extension model must be excluded
	excludes.addAll(pimEXT!EStructuralFeature.all.collect(a | a.fqName()));
	
	PSM!JRole.all.select(r | r.uuid = "Anakin.anakin.business.domain.raktar.RaktariTetel.felhasznaloKezeben").first().lower.println("LOWER: ");
	
	for (e in excludes) { 
		e.println("EXC: ");
	}
	
	var additionalRoles : Set<String> = new Set;
	//there are roles that are not mandatory in uml, but must be included due to business requirement
	additionalRoles.add("Anakin.anakin.business.domain.ugylet.elzalogositas.Ajanlat.zalogtetelek");
	additionalRoles.add("Anakin.anakin.business.domain.ugylet.Szerzodes.zalogtargyBecslesek");
	additionalRoles.add("Anakin.anakin.business.domain.targy.ZalogtargyBecsles.zalogtargy");
	additionalRoles.add("Anakin.anakin.business.domain.targy.Zalogtargy.feljegyzesek");
	additionalRoles.add("Anakin.anakin.business.domain.targy.Zalogtargy.raktariTetel");
	additionalRoles.add("Anakin.anakin.business.domain.raktar.RaktariTetel.feljegyzesek");
	additionalRoles.add("Anakin.anakin.business.domain.raktar.RaktariTetel.tarolohely");
	additionalRoles.add("Anakin.anakin.business.domain.raktar.Tarolohely.raktar");
	
	var elotoltott : Set<String> = new Set;
	elotoltott.add("anakin.business.domain.ugylet.termek.AdhatoKolcsonSzorzo");
	elotoltott.add("anakin.business.domain.ugylet.termek.Termek");
	elotoltott.add("anakin.business.domain.targy.Arfolyam");
	elotoltott.add("anakin.business.domain.ugylet.termek.Dijszabas");
	elotoltott.add("anakin.business.domain.targy.Finomsag");
	elotoltott.add("anakin.business.domain.ugylet.termek.KolcsonSema");
	elotoltott.add("anakin.business.domain.szervezet.KozvetitoCeg");
	elotoltott.add("anakin.business.domain.felhasznalo.Privilegium");
	elotoltott.add("anakin.business.domain.felhasznalo.Szerepkor");
	elotoltott.add("anakin.business.domain.targy.TargyleirasRoviditesek");
	elotoltott.add("anakin.business.domain.ugylet.termek.TermekKategoria");
	elotoltott.add("anakin.business.domain.ugylet.termek.Termek");
	elotoltott.add("anakin.business.domain.ugylet.termek.Termekverzio");
	elotoltott.add("anakin.business.domain.ugylet.UzletiKonfiguracio");
	elotoltott.add("anakin.business.domain.targy.Zalognem");
	
	var enumClasses = PSM!JClass.all.select(c | c.representsEnum).collect(c | c.fqName()).asSet();
	
	//var mandatoryAttributes : Set<String> = PSM!JAttribute.all.select(a | a.lower > 0).collect(a | a.uuid.substring(a.uuid.indexOf(".") + 1, a.uuid.length())).asSet();

	//the class from where we want to start the transitive colsure on mandatory role relation	
	var startClassName = "anakin.business.domain.ugylet.elzalogositas.ElzalogositasSzerzodes";
	var startClass = PSM!JClass.all.selectOne(c | c.fqName() = startClassName);
	var classUUIDs : Set<String> = new Set;
	classUUIDs.add(startClass.uuid);
	startClass.allMandatoryRoles(classUUIDs);
	classUUIDs = classUUIDs.collect(a | a + "_View").asSet();
	var viewNames : Set<String> = RDBMS!RdbmsView.all.select(v | classUUIDs.contains(v.uuid)).name.asSet();
}

operation PSM!JClass allMandatoryRoles(acc : Set<String>) {
	for (r in PSM!JRole.all.select(r | r.ownerClass = self or r.ownerClass = self.supertype)) { //supertype collctor must be recursive 
		if (r.lower > 0 or additionalRoles.contains(r.uuid)) {
			var opp = r.opposite().ownerClass;
			if (not opp.`abstract` and not acc.contains(opp.uuid)) {
				acc.add(opp.uuid);
				r.opposite().ownerClass.allMandatoryRoles(acc);
			}
		}
	}
}

@abstract
rule Element 
	transform s : RDBMS!RdbmsElement
	to 		  t : MIG!RdbmsElement {
	guard: not s.name.contains("@") //TODO: find out why multichained derived expressions maps to valueField
		t.name = s.name;
		t.uuid = s.uuid;
		t.fullName = s.fullName;
		t.description = s.description;
		t.shortName = s.sqlName; // I am using the shortName for storing the original sqlName for later use
		t.sqlName = s.name.cutFqNameToLastElement();
		t.originalName = s.originalName;
	    t.originalPackage = s.originalPackage;
}

@abstract
rule ViewField 
	transform s : RDBMS!RdbmsViewTableField
	to 		  t : MIG!RdbmsField
	extends Element {
		t.rdbmsTypeName = s.tableField.rdbmsTypeName;
		t.size = s.tableField.size;
		t.precision = s.tableField.precision;
		t.scale = s.tableField.scale;
		t.storageByte = s.tableField.storageByte;
		t.mandatory = s.tableField.mandatory;
}

rule Model 
	transform s : RDBMS!RdbmsModel
	to 		  t : MIG!RdbmsModel {
		t.version = s.version;
		for (v in s.rdbmsViews) {
			if (viewNames.contains(v.name)) {
				t.rdbmsTables.add(v.equivalent());
			} 
		}
	}

@lazy
rule View 
	transform s : RDBMS!RdbmsView
	to 		  t : MIG!RdbmsTable
	extends Element {
		var pk = s.primaryIdentifierField;
	    t.primaryKey = pk.equivalent();
	    t.fields.add(t.primaryKey);
	    for (f in s.fields) {
	    	if (not f.isTypeOf(RDBMS!RdbmsViewExpressionField) 
	    		and not f.equals(pk) 
	    		and not f.uuid.isExcluded(s.name)
	    		and not t.fields.exists(x | x.name.cutFqNameToLastElement() = f.name.cutFqNameToLastElement())) {
	    		var fe = f.equivalent();
	    		if (fe.isDefined()) {
	    			t.fields.add(fe);
	    		}
	    	}
		}
		if (elotoltott.contains(t.name)) {
			t.shortName.println();
			t.sqlName = "ET_" + t.sqlName;
			t.sqlName.println();
		} else if (enumClasses.contains(t.name)) {
			t.shortName.println();
			t.sqlName = "ENUM_" + t.sqlName;
			t.sqlName.println();
		}
	}

@lazy
rule ViewIdField
	transform s : RDBMS!RdbmsViewIdentifierField
	to t : MIG!RdbmsIdentifierField 
	extends ViewField {
	guard : not RDBMS!RdbmsForeignKey.all.exists(f | f.name = s.name)
}

@lazy
rule ViewValueField
	transform s : RDBMS!RdbmsViewValueField
	to t : MIG!RdbmsValueField 
	extends ViewField {
	guard: not s.tableField.technical 
		   and (not enumClasses.contains(s.tableField.table.name) or s.name.cutFqNameToLastElement() = "code") 
}

@lazy
rule Fk
	transform s : RDBMS!RdbmsForeignKey
	to fk : MIG!RdbmsForeignKey 
	extends Element {
		fk.rdbmsTypeName = s.rdbmsTypeName;
		fk.size = s.size;
		fk.precision = s.precision;
		fk.scale = s.scale;
		fk.storageByte = s.storageByte;
		fk.mandatory = s.mandatory;
		
	    fk.referenceKey = MIG!RdbmsIdentifierField.all.selectOne(f | f.name = s.referenceKey.name);
	    
	    fk.foreignKeySqlName = s.foreignKeySqlName;
		fk.table =  MIG!RdbmsTable.all.selectOne(t | t.name = s.table.name);

		fk.mandatory = s.mandatory;
		
		fk.deleteOnCascade = s.deleteOnCascade;
		fk.readOnly = s.readOnly;
}

@lazy
rule Junction
	transform s : RDBMS!RdbmsJunctionTable
	to j : MIG!RdbmsJunctionTable 
	extends Element {
		for (i in s.fields.select(f | f.isTypeOf(RDBMS!RdbmsIdentifierField))) {
			var p : RDBMS!RdbmsIdentifierField = new RDBMS!RdbmsIdentifierField;
			p.name = i.name;
			p.sqlName = i.sqlName;
			p.rdbmsTypeName = i.rdbmsTypeName;
			p.uuid =  i.uuid;
			p.rdbmsTypeName = i.rdbmsTypeName;
			p.size = i.size;
			p.precision = i.precision;
			p.scale = i.scale;
			p.storageByte = i.storageByte;
			p.mandatory = i.mandatory;		
			j.fields.add(p);
		}
		
		var n = s.name.split(" to ").collect(s | s.cutFqNameToLastElement());
		j.sqlName = n.first() + "_" + n.second() ;

		j.field1 = s.field1.equivalent();
		j.field2 = s.field2.equivalent();
}

operation String cutFqNameToLastElement() : String {
	var start = self.lastindexOf(".");
	return self.substring(start + 1, self.length());
}

operation String isExcluded(viewName : String) : Boolean {
	var e = excludes.collect(e | "Anakin." + e + "_ViewField@Anakin." + viewName + "_View");
	return e.contains(self) ;
}

post {
	for (fk in RDBMS!RdbmsForeignKey.all) {
	    var refKey = MIG!RdbmsIdentifierField.all.selectOne(f | f.name = fk.referenceKey.name);
	    var fkName = "Anakin." + fk.name;
	    var isMandatory = PSM!JRole.all.selectOne(r | r.uuid = fkName and r.lower > 0).isDefined();
	    var table = MIG!RdbmsTable.all.selectOne(t | t.name = fk.table.name);
	    if (refKey.isDefined() 
	    	and table.isDefined() 
	    	and (isMandatory or additionalRoles.contains(fkName)) 
	    	and not excludes.contains(fk.name)) {
			fk.equivalent();
	    }
	}
	for (j in RDBMS!RdbmsJunctionTable.all) {
		var table1 = MIG!RdbmsTable.all.selectOne(t | t.name = j.field1.referenceKey.table.name);
		var table2 = MIG!RdbmsTable.all.selectOne(t | t.name = j.field2.referenceKey.table.name);
		var refKey1 = MIG!RdbmsIdentifierField.all.selectOne(f | f.name = j.field1.referenceKey.name);
		var refKey2 = MIG!RdbmsIdentifierField.all.selectOne(f | f.name = j.field1.referenceKey.name);
		if (table1.isDefined() and table2.isDefined() and refKey1.isDefined() and refKey2.isDefined()) {
			MIG!RdbmsModel.all.first().rdbmsTables.add(j.equivalent()); 
		}
	}
	
	"END".println();
}